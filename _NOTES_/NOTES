Implementation Plans/Thoughts/Notes
    document (don't have many excuses left...)

*   import/export from file
*   import/export from url (tie into hs.http)

    other interesting NSString methods (see NOTES_objc)

*   compare strings (__le, __lt)        -- uses `hs.text.utf16.compare` with "literal" option
*       method with additional options? -- `hs.text.utf16.compare`
*   equality method with options?       -- use `hs.text.utf16.compare` and test for 0

-   find, match, gmatch, gsub -- allow pattern to be utf16 object? -- wait until this is asked for

> inspect1(string)
{
// Done
  lower = <function 9>,     // in utf16 submodule
  upper = <function 17>     // in utf16 submodule
  sub = <function 15>,      // in utf16 submodule
  reverse = <function 14>,  // in utf16 submodule

  len = <function 8>,       // in both; utf16 version returns unichar count

// utf16.unitCharacter almost does this but out of range indices give error, not no result... ponder
  byte = <function 1>,      // in main module: hs.text:rawData():byte([i],[j]) wrapped in lua

  find = <function 4>,      // uses http://userguide.icu-project.org/strings/regexp; should we convert to lua style?
  match = <function 10>,    // uses http://userguide.icu-project.org/strings/regexp; should we convert to lua style?
  gmatch = <function 6>,    // uses http://userguide.icu-project.org/strings/regexp; should we convert to lua style?
  gsub = <function 7>,      // uses http://userguide.icu-project.org/strings/regexp; should we convert to lua style?

      // Uncertain
        rep = <function 13>,      //  easyish, but is it really useful?

// Probably Not
  char = <function 2>,      // use `hs.text.new(string.char(...))`; utf16 version mirrors utf8.char below
  format = <function 5>,    // use `hs.text[.utf16].new(string.format(...)[, encoding])` to create formatted string in required encoding

// No
  dump = <function 3>,      // binary representation of lua functions -- encoding would destroy
  pack = <function 11>,     // binary encoding of data in portable string -- encoding would destroy
  packsize = <function 12>, // binary encoding of data in portable string -- encoding would destroy
  unpack = <function 16>,   // binary encoding of data in portable string -- encoding would destroy
}

> inspect1(utf8)
{
// done
  codepoint = <function 2>, // in utf16 submodule
  codes = <function 3>,     // in utf16 submodule
  char = <function 1>,      // in utf16 submodule
  len = <function 4>,       // characterCount, combining surrogates and optionally composed character sequences
  offset = <function 5>     // make more generic -- n'th char of encoding, return byte position in the rawData

// No
  charpattern = "....",     // used to iterate UTF8 in 8bit world; better to use module len and sub
}

Still need to review Unicode Normalization wiki and compare to NSString normalization methods to see if sufficient or if something more required.

